---
title: "Spatial Temporal Diversity By Tow"
output: html_notebook # make this github_document to make a .md file instead that will show up on github
---
```{r setup}
library(data.table)
library(ggplot2)
library(geosphere)
library(vegan)
```

### Load and set up data
```{r data}
# only Northeast US spring: test case for now
load("data/NE_trawl_data_full.Rdata")
neus_full.ID <- neus_full.ID[SEASON == 'SPRING', ]

# add tow ID for each lat/lon/year/stratum/season (latter just to be safe)
neus_full.ID[ , haulid := .GRP, by = .(LON, LAT, YEAR, STRATUM, SEASON)]
```

### Calculate distance between tows for each year
```{r community and geographic distance calculations by year}
yrs <- neus_full.ID[, sort(unique(YEAR))]

for(yr in yrs){
  # geographic distance between tows
  distgeo <- distm(neus_full.ID[YEAR == yr, .(haulid, LON, LAT)][!duplicated(haulid), .(LON, LAT)]) # geographic distance matrix
  rownames(distgeo) <- colnames(distgeo) <- neus_full.ID[YEAR == yr, .(haulid)][!duplicated(haulid), haulid]
  distgeo.l <- data.table(melt(as.matrix(distgeo), varnames = c("tow1", "tow2"), value.name = "distgeo")) #matrix to long data.table
  distgeo.l <- distgeo.l[tow1 > tow2,] # get rid of repetitions and self-comparisons
  
  # create community matrix
  commat <- dcast(neus_full.ID[YEAR == yr, .(pres = 1, haulid, SVSPP)], haulid ~ SVSPP, value.var = "pres", fun.aggregate = length) #long to wide data for community matrix, column names are haulid then each SVSPP. This adds zeros automatically through length()

  # community dissimilarity distances between tows
  distcom <- as.matrix(vegdist(commat[,2:ncol(commat)], method = "jaccard", binary = TRUE)) #dissimilarity 
  colnames(distcom) <- rownames(distcom) <- commat$haulid
  distcom.l <- data.table(melt(distcom, varnames = c("tow1", "tow2"), value.name = "jaccard_dissimilarity")) # matrix to long data.table
  distcom.l <- distcom.l[tow1 > tow2,] # to get rid of repetitions and self-comparisons

  #add year for these values
  distcom.l[, year := yr]

  #merge distance with jaccard_dissimilarity for this year
  thisdist <- merge(distgeo.l , distcom.l, by = c('tow1', 'tow2'))

  # add to output table if it already exists
  # create output table if this is the first loop through
  if(yr == yrs[1]) dist <- thisdist
  if(yr != yrs[1]) dist <- rbind(dist, thisdist)
}

dist #here we have jaccard and geographic distance
```

### Plot distance decay for each year
```{r plot distance decay all years}
distdec_byyr <- ggplot(data = dist, aes(x = distgeo, y = 1-jaccard_dissimilarity)) +
  geom_point(shape = 1, size = 0.5, alpha = 0.005) +
  theme_classic() +
  labs(x = "Distance (m)", y = "Jaccard Similarity") +
  theme(text=element_text(size = 8), 
        axis.text.x = element_text(angle = 90),
        strip.text.x = element_text(size = 5)) +
  geom_smooth() + 
  facet_wrap( ~ year, ncol = 8)

# display plot: the slow part
distdec_byyr

# save plot: also slow
ggsave(distdec_byyr, path = "plots/", file = "distance_decay_tow_year.png", dpi = 300, width = 8, height = 8, units = 'in')


```

### Extract coefficient (slope) for each year: how does it change through time?
```{r each year build linear model}
# get slopes
# could do this as quantile regression to get median (from Magurran et al.)
mod_coefs <- data.table("year" = yrs, "beta" = 0)
for (i in 1:length(yrs)) {
  # Estimate the parameters using a linear model for this year
  mod <- lm(jaccard_dissimilarity ~ distgeo, data = dist[year == yrs[i],])  
  mod_coefs[i, beta :=  coef(mod)[2]]
}

# plot
invisible(mod_coefs[ , plot(year, beta)]); invisible(mod_coefs[, abline(lm(beta ~ year))])

```
