---
title: "NEUS Distance Decay over Time"
output: html_notebook
---

```{r setup}
library(data.table)
library(vegan)
library(ggplot2)
library(broom) #augment
library(betapart)

#load spring and fall data
dat_NEUS_grid.spring.reduced_3plustows <- readRDS("/Users/zoekitchel/Documents/grad school/Rutgers/Repositories/trawl_spatial_turnover/data/gridded/USA-NEUS/dat_NEUS_grid.spring.reduced_3plustows.RData")

dat_NEUS_grid.fall.reduced_3plustows <- readRDS("/Users/zoekitchel/Documents/grad school/Rutgers/Repositories/trawl_spatial_turnover/data/gridded/USA-NEUS/dat_NEUS_grid.fall.reduced_3plustows.RData")

#distance among grid cells
neus_reg_distances_fall.l <- readRDS("/Users/zoekitchel/Documents/grad school/Rutgers/Repositories/trawl_spatial_turnover/data/gridded/USA-NEUS/neus_reg_distances_fall.l.RData")

neus_reg_distances_spring.l <- readRDS("/Users/zoekitchel/Documents/grad school/Rutgers/Repositories/trawl_spatial_turnover/data/gridded/USA-NEUS/neus_reg_distances_spring.l.RData")


```

In this iteration of the analysis, each tow will be analyzed independently--I will not be summing or averaging over cells. However, I did use cells in order to eliminate undersampled years/tows

Setup betapart object

```{r set up betapart object}
#spring
#testing 1973

#for presence absense matrix, all values !=0 are 1s
#just 1973
dat_NEUS_spring_1973 <- dat_NEUS_grid.spring.reduced_3plustows[year == 1973,] 

#long to wide
dat_NEUS_spring_1973.w <- dcast(dat_NEUS_spring_1973, as.factor(haulid) ~ as.factor(matched_name2), value.var = "wtcpue", fill = 0, fun=sum)

index_spring <- dat_NEUS_spring_1973.w[,1]
spp_only_spring <- dat_NEUS_spring_1973.w[,2:ncol(dat_NEUS_spring_1973.w)]

spp_only_spring[spp_only_spring > 0] <- as.numeric(1)

dat_NEUS_spring_1973.w.pres <- cbind(index_spring, spp_only_spring)
rownames(dat_NEUS_spring_1973.w.pres) <- dat_NEUS_spring_1973.w.pres$haulid

#now, use betapart to construct objects to be used in decay models
neus_spring_beta.pair <- beta.pair(dat_NEUS_spring_1973.w.pres[,2:ncol(dat_NEUS_spring_1973.w.pres)])
neus_spring_beta.pair.abund <- beta.pair.abund(dat_NEUS_spring_1973.w[,2:ncol(dat_NEUS_spring_1973.w)]) #this takes some time


#fall
#testing 1972

#for presence absense matrix, all values !=0 are 1s
#just 1972
dat_NEUS_fall_1972 <- dat_NEUS_grid.fall.reduced_3plustows[year == 1972,] 

#long to wide
dat_NEUS_fall_1972.w <- dcast(dat_NEUS_fall_1972, as.factor(haulid) ~ as.factor(matched_name2), value.var = "wtcpue", fill = 0, fun=sum)

index_fall <- dat_NEUS_fall_1972.w[,1]
spp_only_fall <- dat_NEUS_fall_1972.w[,2:ncol(dat_NEUS_fall_1972.w)]

spp_only_fall[spp_only_fall > 0] <- as.numeric(1)

dat_NEUS_fall_1972.w.pres <- cbind(index_fall, spp_only_fall)
rownames(dat_NEUS_fall_1972.w.pres) <- dat_NEUS_fall_1972.w.pres$haulid

#now, use betapart to construct objects to be used in decay models
neus_fall_beta.pair <- beta.pair(dat_NEUS_fall_1972.w.pres[,2:ncol(dat_NEUS_fall_1972.w.pres)])
neus_fall_beta.pair.abund <- beta.pair.abund(dat_NEUS_fall_1972.w[,2:ncol(dat_NEUS_fall_1972.w)]) #this takes some time
```

Build exponential for each year

SPRING
```{r each year build exponential model for spring}

#years
neus_years_spring <- unique(dat_NEUS_grid.spring.reduced_3plustows[,year])

neus_similarity_mod_coefs <- data.table("year" = neus_years_spring, "jaccard_total_initial_sim" = 0, "jaccard_total_halving" = 0, "jaccard_turnover_initial_sim" = 0, "jaccard_turnover_halving" = 0, "bray_total_initial_sim" = 0, "bray_total_halving" = 0, "bray_balanced_initial_sim" = 0, "bray_balanced_halving" = 0)


for (i in 1:length(neus_years_spring)) {
  
  reduced_year <- dat_NEUS_grid.spring.reduced_3plustows[year == neus_years_spring[i],]
  
  #distances among cells
  setorder(reduced_year, haulid)
  lat_lon_haulid <- unique(reduced_year[,.(lat,lon,haulid)])
  
  distances <- distm(lat_lon_haulid[,.(lon, lat)])
  
  distances <- as.dist(distances)
  
  #throw to wide
  
  reduced_year_wide <- dcast(reduced_year, haulid ~ matched_name2, value.var = "wtcpue", fill = 0, fun.aggregate = sum) #long to wide data for community matrix, column names are cell then species
  
#for presence absense matrix, all values !=0 are 1s
index <- reduced_year_wide[,1]
spp_only <- reduced_year_wide[,2:ncol(reduced_year_wide)]

spp_only[spp_only > 0] <- as.numeric(1)

reduced_year_wide.pres <- cbind(index, spp_only)
rownames(reduced_year_wide.pres) <- reduced_year_wide.pres$haulid

#now, use betapart to construct objects to be used in decay models

beta.pair <- beta.pair(reduced_year_wide.pres[,2:ncol(reduced_year_wide.pres)], index.family = "jaccard")
beta.pair.abund <- beta.pair.abund(reduced_year_wide[,2:ncol(reduced_year_wide)], index.family = "bray")
  
#bray balanced (turnover)
  fit_bray_balanced <- decay.model(1-beta.pair.abund$beta.bray, distances, model.type = "exp", y.type = "sim") # 1 minus because output of betadist object gives us dissimilarity
  
#    fit_bray$a.intercept = intercept of the model
  intercept_bray_balanced <- fit_bray_balanced$a.intercept
#    fit_bray_balanced$b.slope = rate at which similarity decreases with distance in a neg exponential model
  slope_bray_balanced <- fit_bray_balanced$b.slope
  
  halving_distance_bray_balanced <- log(2)/(-slope_bray_balanced) #halving distance
  
  neus_similarity_mod_coefs[i,"bray_balanced_halving"] <- halving_distance_bray_balanced
  
  initial_sim_bray_balanced <- fit_bray_balanced$a.intercept*1+fit_bray_balanced$b.slope # initial similarity

  
  neus_similarity_mod_coefs[i,"bray_balanced_initial_sim"] <- initial_sim_bray_balanced
  
  
#bray total (nestedness and turnover)  
  #bray balanced (turnover)
  fit_bray_total <- decay.model(1-beta.pair.abund$beta.bray, distances, model.type = "exp", y.type = "sim") # 1 minus because output of betadist object gives us dissimilarity
  
#    fit_bray$a.intercept = intercept of the model
  intercept_bray_total <- fit_bray_total$a.intercept
#    fit_bray_total$b.slope = rate at which similarity decreases with distance in a neg exponential model
  slope_bray_total <- fit_bray_total$b.slope
  
  halving_distance_bray_total <- log(2)/(-slope_bray_total) #halving distance
  
  neus_similarity_mod_coefs[i,"bray_total_halving"] <- halving_distance_bray_total
  
  initial_sim_bray_total <- fit_bray_total$a.intercept*1+fit_bray_total$b.slope # initial similarity

  
  neus_similarity_mod_coefs[i,"bray_total_initial_sim"] <- initial_sim_bray_total
  
  ########
  #jaccard turnover
  #I can't get this to run when I'm looking at presence absense
  fit_turnover_jaccard <- decay.model(1-beta.pair$beta.jtu, distances, y.type = "similarities", model.type = "exp") #beta.jtu dissimilarity matrix accounting for spatial turnover, measured as the turnoverfraction of Jaccard pair-wise dissimilarity
  
  #    fit_jaccard$a.intercept = intercept of the model
  intercept_turnover_jaccard <- fit_turnover_jaccard$a.intercept
#    fit_jaccard$b.slope = rate at which similarity decreases with distance in a neg exponential model
  slope_turnover_jaccard <- fit_turnover_jaccard$b.slope
  
  halving_distance_turnover_jaccard <- log(2)/(-slope_turnover_jaccard) #halving distance
  
  neus_similarity_mod_coefs[i,"jaccard_turnover_halving"] <- halving_distance_turnover_jaccard
  
  initial_sim_turnover_jaccard <- fit_turnover_jaccard$a.intercept*1+fit_turnover_jaccard$b.slope # initial similarity

  
  neus_similarity_mod_coefs[i,"jaccard_turnover_initial_sim"] <- initial_sim_turnover_jaccard
  
  #total jaccard from pres abs data
    fit_total_jaccard <- decay.model(1-beta.pair$beta.jac, distances, y.type = "similarities", model.type = "exp") #beta.jtu dissimilarity matrix accounting for spatial total, measured as the totalfraction of Jaccard pair-wise dissimilarity
  
  #    fit_jaccard$a.intercept = intercept of the model
  intercept_total_jaccard <- fit_total_jaccard$a.intercept
#    fit_jaccard$b.slope = rate at which similarity decreases with distance in a neg exponential model
  slope_total_jaccard <- fit_total_jaccard$b.slope
  
  halving_distance_total_jaccard <- log(2)/(-slope_total_jaccard) #halving distance
  
  neus_similarity_mod_coefs[i,"jaccard_total_halving"] <- halving_distance_total_jaccard
  
  initial_sim_total_jaccard <- fit_total_jaccard$a.intercept*1+fit_total_jaccard$b.slope # initial similarity

  
  neus_similarity_mod_coefs[i,"jaccard_total_initial_sim"] <- initial_sim_total_jaccard

}

ggplot(aes(x = as.numeric(year)), data = neus_similarity_mod_coefs) +
  geom_point(aes(y = jaccard_total_halving), shape = 15) +
  geom_smooth(aes(y = jaccard_total_halving), linetype = 1, color = "black") +
  geom_point(aes(y = jaccard_turnover_halving), shape = 15, color = "green") +
  geom_smooth(aes(y = jaccard_turnover_halving), linetype = 1, color = "green") +
  labs(x = "Year", y = "Jaccard Similarity Halving Distance (m)") +
  theme_classic() +
  theme(text = element_text(size = 13))

ggplot(aes(x = as.numeric(year)), data = neus_similarity_mod_coefs) +
  geom_point(aes(y = bray_total_halving), color = "black") +
  geom_smooth(aes(y = bray_total_halving), color = "black") +
  geom_point(aes(y = bray_balanced_halving), color = "green") +
  geom_smooth(aes(y = bray_balanced_halving), color = "green") +
  labs(x = "Year", y = "Bray Similarity Halving Distance (m)") +
  theme_classic() +
  theme(text = element_text(size = 13))

ggsave(path = "plots", file = "slopes_for_distance_decay.jpg", width = 6, height = 4, unit = "in")


#increasing rate of decay through time (strata become less similar through time)

```